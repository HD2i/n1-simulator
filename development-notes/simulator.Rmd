---
title: "Reimplementation Work for N-of-1 Simulator"
author: "Ed Baskerville"
date: "4/20/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The code was originally developed in this notebook and then moved into the `n1simulator` package.
For consistency, the code has been removed from the notebook and is sourced here:

```{r}
source('../n1simulator/R/n1simulator.R')
```

## Conceptual overview

Conceptually, the simulator is implemented in *continuous time*, and the various processes, including the baseline outcome process ($B(t)$), the determistic effect processes ($\mathbf{X}(t)$), and the final outcome process ($Z(t)$) are all realized as *vectorized continuous functions of time*.

This removes the brittleness of matching simulation events to discrete indices, simplifying the code and making it easier to generalize.
Because these functions are vectorized, they should perform fairly well without C optimizations.

For $X_j(\mathbf{t})$, the code precomputes the initial values of each segment of the simulation by calculating the exponential decay from the previous change point, and then constructs a (vectorized) function to match a vector of values of $t$ to corresponding vectors of initial conditions and parameters, and then (vectorizedly) computes the exponential decay at each point.

For $B(t)$, by default the code computes a Brownian drift in discrete time and returns an linearly interpolating function.
This means that the drift process can have different timesteps from the rest of the simulation.
But it also means that the baseline function can be replaced by *any* R function, including, e.g., `function(t) 10 + 0.1 * t`.

The code for the outcome process $Z(t)$ simply calls $B(t)$ and each $X_j(t)$ with a vector of timepoints, and returns a linearly interpolating function.

Finally, the outcome sampling process ${\hat{Z}}(t)$ simply evaluates the outcome process at arbitrary timepoints and applies noise and transformations.


## Deterministic effect process

Each deterministic effect process is simply a stepwise series of exponential decays, with equilibria corresponding to either 0 or $E$ and decay rates corresponding to $\tau$ or $\gamma$.

The function `make_effect_function` precomputes initial values for each period of the simulation and returns a function that can evaluate the deterministic effect $X(t)$ for an arbitrary vector of time values.

For visualization purposes, it's also useful to have an analogous function, `make_treatment_function` that simply shows an input treatment binary vector over time.

Here's an example of constructing and using an effect function:

```{r}
X_initial <- 3
t_change_vec <- c(0, 1, 2, 3, 4)
E <- 5
treatment_vec <- c(0, 1, 1, 0)
tau0 <- 0.1
tau1 <- 0.5
test_X_func <- make_effect_function(X_initial, t_change_vec, treatment_vec, E, tau0, tau1)
t_vec <- seq(0, 4, 0.01)
X_vec <- test_X_func(t_vec)
plot(t_vec, X_vec, type = 'l')

test_T_func <- make_treatment_function(t_change_vec, treatment_vec)
T_vec <- test_T_func(t_vec)
lines(t_vec, E * T_vec, type = 'l', lty=2)
abline(v = t_change_vec, lty=3)
```

## Baseline function

The baseline function, by default, is a Brownian motion/Wiener process, which can be constructed using `make_brownian_baseline_function`

```{r}
B_func <- make_brownian_baseline_function(160, 1.0, 0, 120, 0.01)
t_vec <- seq(0, 120, 0.05)
plot(t_vec, B_func(t_vec), type = 'l', ylim = c(100, 170))
```

## Simulator

The general-purpose simulation function `n_simulate_general` takes model parameters, including treatments over time and an arbitrary baseline function, simulates the model state, and returns a list containing interpolating functions $B$, a list of $T$s, a list of $X$s, and $Z$.

```{r}
t_change_vec <- seq(0, 120, 30)
B_func <- make_brownian_baseline_function(160, 0.4, 0, 120, 0.01)
E_vec <- c(-40, -30)
T_mat <- matrix(c(
  0, 1, 1, 0,
  1, 0, 0, 1
), ncol = 2, byrow = FALSE)
tau0_vec <- c(3.0, 1.0)
tau1_vec <-  c(6.0, 2.0)
tc_outcome <- 2.0
sigma_Z <- 1.0
dt <- 0.01
```

```{r}
result <- n1_simulate_general(t_change_vec,  B_func, E_vec, T_mat, tau0_vec, tau1_vec, tc_outcome, sigma_Z, dt)
```

```{r}
t_samp_vec <- seq(0, 120, 1)
plot(t_samp_vec, result$T_funcs[[1]](t_samp_vec), type = 'l', ylab = 'treatments')
lines(t_samp_vec, result$T_funcs[[2]](t_samp_vec), lty = 2)
```

```{r}
plot(t_samp_vec, result$X_funcs[[1]](t_samp_vec), type = 'l', ylab = 'treatment effects', ylim = c(0, -40))
lines(t_samp_vec, result$X_funcs[[2]](t_samp_vec), lty = 2)
```

```{r}
plot(t_samp_vec, result$B_func(t_samp_vec), type = 'l', ylim = c(100, 160), ylab = 'systolic blood pressure')
lines(t_samp_vec, result$Z_func(t_samp_vec))
```


## Observations

Observations are simply normal noise applied to simulated outcomes, implemented in the `n1_observe_outcome` function.

```{r}
t_obs_vec <- seq(0, 120, 1)
sigma_obs <- 4.0
Z_obs_vec <- n1_observe_outcome(result$Z_func, t_obs_vec, sigma_obs)
plot(t_obs_vec, Z_obs_vec, ylim = c(100, 160))
lines(t_obs_vec, result$Z_func(t_obs_vec))
```

Observation times can be arbitrary continuous values between timesteps if you like:

```{r}
t_obs_vec_weird <- sort(runif(120, min = 0, max = 120))
Z_obs_vec_weird <- n1_observe_outcome(result$Z_func, t_obs_vec_weird, sigma_obs)
plot(t_obs_vec_weird, Z_obs_vec_weird, ylim = c(100, 160))
lines(t_obs_vec_weird, result$Z_func(t_obs_vec_weird))
```

## Transformations

TODO

## Speed

Fine. 0.06 seconds for dt = 0.01. 0.8 seconds for dt = 0.001.

```{r}
t_change_vec <- seq(0, 120, 30)
B_func <- make_brownian_baseline_function(160, 0.4, 0, 120, 0.01)
E_vec <- c(-40, -30)
T_mat <- matrix(c(
  0, 1, 1, 0,
  1, 0, 0, 1
), ncol = 2, byrow = FALSE)
tau0_vec <- c(3.0, 1.0)
tau1_vec <-  c(6.0, 2.0)
tc_outcome <- 2.0
sigma_Z <- 1.0
```

```{r}
sapply(c(0.1, 0.01, 0.001), function(dt) {
  system.time({
    n1_simulate_general(t_change_vec,  B_func, E_vec, T_mat, tau0_vec, tau1_vec, tc_outcome, sigma_Z, dt)
  })
})
```


## Simplified data generation

The function `n1_simulate` is a simplified interface for data generation for a single simulation that matches the parameters in the paper.
It is less flexible than the general-purpose simulator, imposing the following restrictions:

* The function returns an R data frame with observations and underlying state variables reported at a fixed interval.
* The baseline trajectory is simulated as a discretized Brownian motion rather than an arbitrary user-provided function.
* Treatment periods are of a fixed duration.
* Treatments are provided as a vector of integers in `1:n_treatments`, so only one treatment is active at a time.

```{r}
df <- n1_simulate(
  n_blocks = 4, n_treatments = 2,
  baseline_initial = 160, effect_size_vec = c(-40, -30),
  tc_in_vec = c(3, 2), tc_out_vec = c(2, 3), tc_outcome = 1,
  sd_baseline = 0.4, sd_outcome = 0.6, sd_obs = 4.0,
  treatment_period = 30.0, sampling_timestep = 1.0, noise_timestep = 0.05
)
print(df)
plot(df$t, df$block)
plot(df$t, df$treatment)
plot(df$t, df$treatment_1)
plot(df$t, df$treatment_2)
plot(df$t, df$effect)
plot(df$t, df$effect_1)
plot(df$t, df$effect_2)
plot(df$t, df$outcome, type = 'l')
```

```{r}
result <- n1_simulate(
  n_blocks = 1, n_treatments = 2,
  baseline_initial = 160, effect_size_vec = c(-40, -30),
  tc_in_vec = c(3, 2), tc_out_vec = c(2, 3), tc_outcome = 1,
  sd_baseline = 0.4, sd_outcome = 0.6, sd_obs = 4.0,
  treatment_period = 30.0, sampling_timestep = 1.0, noise_timestep = 0.05,
  return_data_frame = FALSE
)
print(result)
plot(result$t, result$block)
plot(result$t, result$treatment)
plot(result$t, result$treatment_by_treatment[,1])
plot(result$t, result$treatment_by_treatment[,2])
plot(result$t, result$effect)
plot(result$t, result$effect_by_treatment[,1])
plot(result$t, result$effect_by_treatment[,2])
plot(result$t, result$outcome, type = 'l')
points(result$t, result$outcome_obs)
```


## Parameter sweeps

```{r}
n1_generate_parameters <- function(
  study_duration 
)
```

```{r}
n1_run_experiment <- function(
  n_replicates,
  
  n_blocks,
  n_treatments,
  
  baseline_initial,
  effect_size_vec,
  tc_in_vec,
  tc_out_vec,
  tc_effect_delay,
  
  sd_baseline,
  sd_outcome,
  sd_obs,
  
  treatment_period,
  sampling_timestep,
  noise_timestep,
)
```

```{r}
data.frame(
  trial_id = 1,
  replicate_id = 1,
  
  n_blocks = 4,
  n_treatments = 2,
  
  baseline_initial = 160,
  
  effect_size_1 = -40,
  tc_in_1 = 6,
  tc_out_1 = 3,
  
  effect_size_2 = -30,
  tc_in_1 = 2,
  tc_out_1 = 10,
  
  tc_effect_delay = 1,
  
  
  sd_baseline = 0.4,
  sd_outcome = 1.0,
  sd_obs = 4.0,
  
  treatment_period = 30.0,
  sampling_timestep = 1.0,
  
  noise_timestep = 0.01,
  treatment_order = "1221211212211221",
  random_seed = 823456782323,
  
  effect_size_1_est_m1 = -35.234,
  effect_size_1_pval_m1 = 0.001,
  
  effect_size_1_est_m2 = -37.235,
  effect_size_1_pval_m2 = 0.5,
  
  effect_size_1_est_m3 = -33.534,
  effect_size_1_pval_m3 = 0.07,
  
  effect_size_1_est_m4 = -32.523,
  effect_size_1_pval_m4 = 0.09
)
```

